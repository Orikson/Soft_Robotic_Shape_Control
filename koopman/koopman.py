import numpy as np
from sklearn.linear_model import Lasso, Ridge

def gen_delay_traj(X, U, delay):
    '''
    Given X data matrix and U data matrix and delay, compute time-delayed matrix.

    Assumes X is made of contiguous samples in time i.e.
    [ x1  x2  x3  ... ]

    Args:
        X: [N, D_STATE]
        U: [N, D_INPUT]
        delay: int

    Outputs:
        X: [N-delay, D_STATE*(delay+1)]
        U: [N-delay, D_INPUT]
    '''
    N, D_STATE = X.shape
    _, D_INPUT = U.shape

    res_X = np.zeros((N-delay, D_STATE*(delay+1)))

    for i in range(delay+1):
        res_X[:,D_STATE*i:D_STATE*(i+1)] = X[delay-i:N-i,:]
    
    return res_X, U[delay:,:]

def gen_delay_full(X, U, delay):
    '''
    Given trajectories X and corresponding control input sequences U, generate a
        single matrix for time delayed coordinates.
    
    Args:
        X: [N_traj, N_timesteps, D_STATE]
        U: [N_traj, N_timesteps, D_INPUT]
        delay: int
    
    Outputs:
        X: [N_traj * (N_timesteps-delay-1), D_STATE*(delay+1)]
        U: [N_traj * (N_timesteps-delay-1), D_INPUT]
        Y: [N_traj * (N_timesteps-delay-1), D_STATE]
    '''
    N_traj, N_timesteps, D_STATE = X.shape
    D_INPUT = U.shape[2]

    Xf = np.zeros((N_traj, N_timesteps-delay, D_STATE*(delay+1)))
    Uf = np.zeros((N_traj, N_timesteps-delay, D_INPUT))

    for i in range(N_traj):
        dX, dU = gen_delay_traj(X[i], U[i], delay)
        Xf[i] = dX
        Uf[i] = dU
    
    Xd = Xf[:,:-1,:].reshape(-1, D_STATE*(delay+1))
    Ud = Uf[:,:-1,:].reshape(-1, D_INPUT)
    Yd = Xf[:,1:,:D_STATE].reshape(-1, D_STATE)

    return Xd, Ud, Yd


def make_mats(Y, U, backbone, delay=2, freq=50):
    # Convert a data matrix Y in shape [N_SIMS, N_TIMESTEPS, N_POINTS, N_VARS]
    # And data matrix U in shape [N_SIMS, N_TIMESTEPS, N_INPS]
    # Into appropriately shaped data matrices for Koopman operators, Xf, Uf, and Yf
    
    N_SIMS, N_TIMESTEPS, N_POINTS, N_VARS = Y.shape
    _, _, N_INPS = U.shape

    n_sections = backbone.n_sections
    n = Y[:,:,:backbone.n:freq,:3].shape[2]

    X = np.zeros((N_SIMS, N_TIMESTEPS, n * n_sections, 3))
    
    X[:,:,:n] = Y[:,:,:backbone.n:freq,:3]

    # Make each section relative to its origin
    for section in range(1, n_sections):
        # Get orientation at beginning of the segment (starting from the second segment)
        R = Y[:,:,section*backbone.n,3:12].reshape(N_SIMS, N_TIMESTEPS, 3, 3)
        R_inv = np.linalg.inv(R)

        # Local positions along the entire section
        p = Y[:,:,section*backbone.n:(section+1)*backbone.n:freq,:3]
        p0 = p[:,:,0]

        # Untranslate, and then unrotate
        p = (R_inv[:,:,None,:,:] @ (p - p0[:,:,None,:])[:,:,:,:,None])[:,:,:,:,0]

        # Save
        X[:,:,section*n:(section+1)*n] = p
    
    has_nan = np.any(np.isnan(X), axis=(1,2,3))
    Yf = X[~has_nan]
    Uf = U[~has_nan]

    Yf = Yf.reshape((*Yf.shape[:2], Yf.shape[2]*Yf.shape[3]))

    Xf, Uf, Yf = gen_delay_full(Yf, Uf, delay=delay)

    return Xf, Uf, Yf, X[~has_nan], n

def make_mats_naive(Y, U, backbone, delay=2, freq=50):
    # Convert a data matrix Y in shape [N_SIMS, N_TIMESTEPS, N_POINTS, N_VARS]
    # And data matrix U in shape [N_SIMS, N_TIMESTEPS, N_INPS]
    # Into appropriately shaped data matrices for Koopman operators, Xf, Uf, and Yf
    
    N_SIMS, N_TIMESTEPS, N_POINTS, N_VARS = Y.shape
    _, _, N_INPS = U.shape

    n_sections = backbone.n_sections
    n = Y[:,:,:backbone.n:freq,:3].shape[2]

    X = np.zeros((N_SIMS, N_TIMESTEPS, n * n_sections, 3))
    
    X[:,:,:n] = Y[:,:,:backbone.n:freq,:3]

    # Make each section relative to its origin
    for section in range(1, n_sections):
        # Local positions along the entire section
        p = Y[:,:,section*backbone.n:(section+1)*backbone.n:freq,:3]

        # Save
        X[:,:,section*n:(section+1)*n] = p
    
    has_nan = np.any(np.isnan(X), axis=(1,2,3))
    Yf = X[~has_nan]
    Uf = U[~has_nan]

    Yf = Yf.reshape((*Yf.shape[:2], Yf.shape[2]*Yf.shape[3]))

    Xf, Uf, Yf = gen_delay_full(Yf, Uf, delay=delay)

    return Xf, Uf, Yf, X[~has_nan], n


def iden_koop(X, U, Y, delay, mode=0, alpha=1e-3, tol=1e-4):
    '''
    Identifies a Koopman operator using delay coordinates

    X, U, Y should be generated by gen_delay_full or similar

    Returns square matrix A and conformable matrix B

    Args:
        X (np.array): state data matrix
        U (np.array): control input data matrix
        Y (np.array): time shifted state data matrix
        delay (int): how many delay coordinates are used
        mode (int): 0 for lstsq, 1 for lasso, 2 for ridge
        alpha (float): scaling parameter for modes 1 and 2
    '''
    D_INPUT = U.shape[1]
    D_STATE = Y.shape[1]

    Z = np.hstack([X, U])                               # N x (D_STATE*(delay+1) + D_INPUT)

    if mode == 0:
        F = np.linalg.lstsq(Z, Y, rcond=None)[0].T      # D_STATE x (D_STATE*(delay+1) + D_INPUT)
    elif mode == 1:
        clf = Lasso(alpha=alpha, fit_intercept=False, tol=tol)
        clf.fit(Z, Y)
        F = clf.coef_
    else:
        clf = Ridge(alpha=alpha, fit_intercept=False, tol=tol)
        clf.fit(Z, Y)
        F = clf.coef_
    
    A = np.block([                                                                  # D_STATE*(delay+1) x D_STATE*(delay+1)
        [F[:,:X.shape[1]]],                                                         # D_STATE x D_STATE*(delay+1)
        [np.hstack([np.eye(D_STATE*delay), np.zeros((D_STATE*delay, D_STATE))])]    # D_STATE*delay x D_STATE*(delay+1)
    ])
    B = np.block([                                                                  # D_STATE*(delay+1) x D_INPUT
        [F[:,X.shape[1]:]],                                                         # D_STATE x D_INPUT
        [np.zeros((D_STATE*delay, D_INPUT))]                                        # D_STATE*delay x D_INPUT
    ])
    return A, B
